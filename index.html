<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Corrupted Zone Metroidvania Demo</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #gameCanvas {
      border: 2px solid #444;
      background: #000;
      image-rendering: pixelated;
    }
    #info {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      max-width: 800px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="480"></canvas>
  <div id="info">
    <div><b>Controls:</b> Move: A/D or ←/→ · Jump: W/↑ or Space · Dash: Left Shift · Cling: hold toward wall while in air · Purify: E</div>
    <div>Gray: normal blocks · Purple: corrupted blocks · Green: purified blocks · Red: enemies</div>
  </div>

  <script>
    // =========================
    // BASIC SETUP
    // =========================
    const canvas = document.getElementById("gameCanvas");
    /** @type {CanvasRenderingContext2D} */
    const ctx = canvas.getContext("2d");

    const TILE = 32;
    const GRAVITY = 0.6;
    const FRICTION = 0.8;
    const MOVE_SPEED = 0.8;
    const MAX_X_SPEED = 5;
    const JUMP_FORCE = -11;
    const WALL_JUMP_FORCE_X = 7;
    const WALL_JUMP_FORCE_Y = -10;
    const DASH_SPEED = 14;
    const DASH_TIME = 10; // frames
    const DASH_COOLDOWN = 40; // frames

    // Tile types
    const TILE_EMPTY = 0;
    const TILE_SOLID = 1;
    const TILE_CORRUPTED = 2;
    const TILE_PURIFIED = 3;

    // Simple level (25x15 tiles -> 800x480)
    // 0 empty, 1 solid, 2 corrupted
    const levelData = [
      "0000000000000000000000000",
      "0000000000000000000000000",
      "0000000000000000000000000",
      "0000000000000000000000000",
      "0000000000000000000000000",
      "0000000000000000000000000",
      "0000000000000222200000000",
      "0000000000000111100000000",
      "0000000000000111100000000",
      "0000000022200111100000000",
      "0000000011100111100000000",
      "0000000011100111100000000",
      "1111111111111111111111111",
      "1111111111111111111111111",
      "1111111111111111111111111"
    ].map(row => row.split("").map(n => parseInt(n, 10)));

    const levelWidth = levelData[0].length;
    const levelHeight = levelData.length;

    // =========================
    // INPUT
    // =========================
    const keys = {};
    window.addEventListener("keydown", e => {
      keys[e.key.toLowerCase()] = true;
      if (["ArrowLeft", "ArrowRight", "ArrowUp", " "].includes(e.key)) {
        keys[e.key] = true;
        e.preventDefault();
      }
    });
    window.addEventListener("keyup", e => {
      keys[e.key.toLowerCase()] = false;
      keys[e.key] = false;
    });

    function isLeftPressed() {
      return keys["a"] || keys["arrowleft"];
    }
    function isRightPressed() {
      return keys["d"] || keys["arrowright"];
    }
    function isJumpPressed() {
      return keys["w"] || keys["arrowup"] || keys[" "];
    }
    function isDashPressed() {
      return keys["shift"] || keys["shiftleft"];
    }
    function isPurifyPressed() {
      return keys["e"];
    }

    // =========================
    // PLAYER
    // =========================
    const player = {
      x: 64,
      y: 64,
      w: 24,
      h: 32,
      vx: 0,
      vy: 0,
      onGround: false,
      facing: 1, // 1 right, -1 left
      canDoubleJump: false,
      isWallClinging: false,
      wallDir: 0, // -1 left, 1 right
      isDashing: false,
      dashTimer: 0,
      dashCooldown: 0,
      alive: true,
      respawnX: 64,
      respawnY: 64
    };

    // =========================
    // ENEMIES
    // =========================
    const enemies = [
      {
        x: 500,
        y: 320,
        w: 24,
        h: 24,
        vx: 1.2,
        vy: 0,
        leftBound: 450,
        rightBound: 650,
        corrupted: true
      },
      {
        x: 350,
        y: 256,
        w: 24,
        h: 24,
        vx: -1.5,
        vy: 0,
        leftBound: 300,
        rightBound: 520,
        corrupted: false
      }
    ];

    // =========================
    // HELPERS
    // =========================
    function getTileAtPixel(px, py) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (tx < 0 || ty < 0 || tx >= levelWidth || ty >= levelHeight) return TILE_SOLID;
      return levelData[ty][tx];
    }

    function isSolidTile(t) {
      return t === TILE_SOLID || t === TILE_CORRUPTED || t === TILE_PURIFIED;
    }

    function setTileAtPixel(px, py, val) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (tx < 0 || ty < 0 || tx >= levelWidth || ty >= levelHeight) return;
      levelData[ty][tx] = val;
    }

    function aabbOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function resetPlayer() {
      player.x = player.respawnX;
      player.y = player.respawnY;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;
      player.isDashing = false;
      player.dashTimer = 0;
      player.dashCooldown = 0;
      player.alive = true;
    }

    // =========================
    // UPDATE PLAYER
    // =========================
    function updatePlayer() {
      if (!player.alive) return;

      let move = 0;
      if (isLeftPressed()) move -= 1;
      if (isRightPressed()) move += 1;

      if (move !== 0) player.facing = move;

      // Dash handling
      if (!player.isDashing && player.dashCooldown <= 0 && isDashPressed() && move !== 0) {
        player.isDashing = true;
        player.dashTimer = DASH_TIME;
        player.vx = player.facing * DASH_SPEED;
        player.vy = 0;
      }

      if (player.isDashing) {
        player.dashTimer--;
        if (player.dashTimer <= 0) {
          player.isDashing = false;
          player.dashCooldown = DASH_COOLDOWN;
        }
      } else {
        // Horizontal movement normal
        player.vx += move * MOVE_SPEED;
        player.vx *= FRICTION;
        if (player.vx > MAX_X_SPEED) player.vx = MAX_X_SPEED;
        if (player.vx < -MAX_X_SPEED) player.vx = -MAX_X_SPEED;
      }

      // Apply gravity
      player.vy += GRAVITY;

      // Wall clinging
      player.isWallClinging = false;
      player.wallDir = 0;

      if (!player.onGround && !player.isDashing) {
        // Check for wall on left
        const leftTile1 = getTileAtPixel(player.x - 1, player.y + 4);
        const leftTile2 = getTileAtPixel(player.x - 1, player.y + player.h - 4);
        if (isSolidTile(leftTile1) || isSolidTile(leftTile2)) {
          if (isLeftPressed()) {
            player.isWallClinging = true;
            player.wallDir = -1;
          }
        }
        // Check for wall on right
        const rightTile1 = getTileAtPixel(player.x + player.w + 1, player.y + 4);
        const rightTile2 = getTileAtPixel(player.x + player.w + 1, player.y + player.h - 4);
        if (isSolidTile(rightTile1) || isSolidTile(rightTile2)) {
          if (isRightPressed()) {
            player.isWallClinging = true;
            player.wallDir = 1;
          }
        }

        if (player.isWallClinging) {
          // Slow falling
          if (player.vy > 2) player.vy = 2;
          player.canDoubleJump = true; // allow a "wall jump" + later double jump if you want to extend
        }
      }

      // Jump
      if (isJumpPressed()) {
        if (player.onGround) {
          player.vy = JUMP_FORCE;
          player.onGround = false;
        } else if (player.isWallClinging) {
          // Wall jump
          player.vy = WALL_JUMP_FORCE_Y;
          player.vx = -player.wallDir * WALL_JUMP_FORCE_X;
          player.isWallClinging = false;
        }
      }

      // Move and collide
      let newX = player.x + player.vx;
      let newY = player.y + player.vy;

      // Horizontal collisions
      if (player.vx > 0) {
        // Moving right
        if (
          isSolidTile(getTileAtPixel(newX + player.w, player.y + 2)) ||
          isSolidTile(getTileAtPixel(newX + player.w, player.y + player.h - 2))
        ) {
          newX = Math.floor((newX + player.w) / TILE) * TILE - player.w - 0.01;
          player.vx = 0;
        }
      } else if (player.vx < 0) {
        // Moving left
        if (
          isSolidTile(getTileAtPixel(newX, player.y + 2)) ||
          isSolidTile(getTileAtPixel(newX, player.y + player.h - 2))
        ) {
          newX = Math.floor(newX / TILE + 1) * TILE + 0.01;
          player.vx = 0;
        }
      }

      // Vertical collisions
      let onGround = false;
      if (player.vy > 0) {
        // Falling
        if (
          isSolidTile(getTileAtPixel(newX + 2, newY + player.h)) ||
          isSolidTile(getTileAtPixel(newX + player.w - 2, newY + player.h))
        ) {
          newY = Math.floor((newY + player.h) / TILE) * TILE - player.h - 0.01;
          player.vy = 0;
          onGround = true;
        }
      } else if (player.vy < 0) {
        // Going up
        if (
          isSolidTile(getTileAtPixel(newX + 2, newY)) ||
          isSolidTile(getTileAtPixel(newX + player.w - 2, newY))
        ) {
          newY = Math.floor(newY / TILE + 1) * TILE + 0.01;
          player.vy = 0;
        }
      }

      player.x = newX;
      player.y = newY;
      player.onGround = onGround;

      if (player.dashCooldown > 0 && !player.isDashing) {
        player.dashCooldown--;
      }

      // Purify nearby corrupted tiles
      if (isPurifyPressed()) {
        const radius = 64;
        for (let ty = 0; ty < levelHeight; ty++) {
          for (let tx = 0; tx < levelWidth; tx++) {
            if (levelData[ty][tx] === TILE_CORRUPTED) {
              const centerX = tx * TILE + TILE / 2;
              const centerY = ty * TILE + TILE / 2;
              const dx = centerX - (player.x + player.w / 2);
              const dy = centerY - (player.y + player.h / 2);
              if (dx * dx + dy * dy < radius * radius) {
                levelData[ty][tx] = TILE_PURIFIED;
              }
            }
          }
        }
      }

      // Check falling out of world
      if (player.y > canvas.height + 200) {
        player.alive = false;
        setTimeout(resetPlayer, 500);
      }
    }

    // =========================
    // UPDATE ENEMIES
    // =========================
    function updateEnemies() {
      enemies.forEach(e => {
        e.x += e.vx;

        if (e.x < e.leftBound) {
          e.x = e.leftBound;
          e.vx *= -1;
        }
        if (e.x + e.w > e.rightBound) {
          e.x = e.rightBound - e.w;
          e.vx *= -1;
        }

        // Simple gravity / ground snap
        e.vy += GRAVITY;
        e.y += e.vy;

        // collide with ground
        if (e.y + e.h > canvas.height - TILE * 2) {
          e.y = canvas.height - TILE * 2 - e.h;
          e.vy = 0;
        }

        // Enemy "corrupted" state: faster and more dangerous
        if (e.corrupted) {
          // small behavior change
          e.vx *= 1.0005;
          if (e.vx > 2.5) e.vx = 2.5;
          if (e.vx < -2.5) e.vx = -2.5;
        }

        // Collision with player
        if (player.alive && aabbOverlap(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          if (e.corrupted) {
            // corrupted enemy kills player
            player.alive = false;
            setTimeout(resetPlayer, 500);
          } else {
            // non-corrupted enemy just knocks player back
            player.vx = (player.x < e.x ? -1 : 1) * -6;
            player.vy = -6;
          }
        }

        // If nearby purified tiles, enemy becomes purified (changes color only)
        let nearPurified = false;
        const px = Math.floor((e.x + e.w / 2) / TILE);
        const py = Math.floor((e.y + e.h / 2) / TILE);
        for (let oy = -1; oy <= 1; oy++) {
          for (let ox = -1; ox <= 1; ox++) {
            const tx = px + ox;
            const ty = py + oy;
            if (tx >= 0 && ty >= 0 && tx < levelWidth && ty < levelHeight) {
              if (levelData[ty][tx] === TILE_PURIFIED) {
                nearPurified = true;
              }
            }
          }
        }
        if (nearPurified) {
          e.corrupted = false;
        }
      });
    }

    // =========================
    // DRAW
    // =========================
    function drawLevel() {
      for (let y = 0; y < levelHeight; y++) {
        for (let x = 0; x < levelWidth; x++) {
          const t = levelData[y][x];
          if (t === TILE_EMPTY) continue;
          const px = x * TILE;
          const py = y * TILE;
          if (t === TILE_SOLID) {
            ctx.fillStyle = "#555";
          } else if (t === TILE_CORRUPTED) {
            ctx.fillStyle = "#6a0dad"; // purple
          } else if (t === TILE_PURIFIED) {
            ctx.fillStyle = "#1faa00"; // green
          }
          ctx.fillRect(px, py, TILE, TILE);
        }
      }
    }

    function drawPlayer() {
      if (!player.alive) {
        ctx.globalAlpha = 0.4;
      }
      ctx.fillStyle = "#00bfff";
      ctx.fillRect(player.x, player.y, player.w, player.h);

      // Eye / facing direction
      ctx.fillStyle = "#fff";
      const eyeX = player.facing > 0 ? player.x + player.w - 8 : player.x + 2;
      const eyeY = player.y + 8;
      ctx.fillRect(eyeX, eyeY, 4, 4);
      ctx.globalAlpha = 1.0;
    }

    function drawEnemies() {
      enemies.forEach(e => {
        ctx.fillStyle = e.corrupted ? "#ff3333" : "#ffcc00";
        ctx.fillRect(e.x, e.y, e.w, e.h);
        ctx.fillStyle = "#000";
        ctx.fillRect(e.x + 6, e.y + 6, 4, 4);
      });
    }

    function drawUI() {
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0, 0, 240, 60);
      ctx.fillStyle = "#fff";
      ctx.font = "12px sans-serif";
      ctx.fillText("Corrupted Zone Demo", 10, 18);
      ctx.fillText("Purify (E) near purple tiles", 10, 32);
      ctx.fillText("Dash (Shift), Jump (W/↑/Space)", 10, 46);
    }

    // =========================
    // MAIN LOOP
    // =========================
    function loop() {
      // Update
      updatePlayer();
      updateEnemies();

      // Clear
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw
      drawLevel();
      drawEnemies();
      drawPlayer();
      drawUI();

      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
