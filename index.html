<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Corrupted Zone Metroidvania Demo</title>
  <style>
    body {
      margin: 0;
      background: #050509;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #gameCanvas {
      border: 2px solid #333;
      background: #000;
      image-rendering: pixelated;
      margin-top: 8px;
    }
    #info {
      margin-top: 6px;
      font-size: 13px;
      text-align: center;
      max-width: 900px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="480"></canvas>
  <div id="info">
    <div><b>Controls:</b> Move: A/D or ←/→ · Jump: W/↑/Space · Dash: Left Shift · Attack: J or Z · Purify: E</div>
    <div>Gray = solid · Purple = corrupted · Green = purified · Red = enemies. Climb walls and reach the upper left area.</div>
  </div>

  <script>
    // =========================================================
    // BASIC SETUP
    // =========================================================
    const canvas = document.getElementById("gameCanvas");
    /** @type {CanvasRenderingContext2D} */
    const ctx = canvas.getContext("2d");

    const TILE = 32;

    const GRAVITY = 0.6;
    const FRICTION = 0.8;
    const MOVE_SPEED = 0.8;
    const MAX_X_SPEED = 5;
    const JUMP_FORCE = -11;
    const WALL_JUMP_FORCE_X = 7;
    const WALL_JUMP_FORCE_Y = -10;
    const DASH_SPEED = 14;
    const DASH_TIME = 10;      // frames
    const DASH_COOLDOWN = 40;  // frames

    const ATTACK_TIME = 10;    // frames
    const ATTACK_COOLDOWN = 20;

    // Tile types
    const TILE_EMPTY    = 0;
    const TILE_SOLID    = 1;
    const TILE_CORRUPTED = 2;
    const TILE_PURIFIED = 3;

    // =========================================================
    // WORLD LAYOUT (BIG TILEMAP)
    // width = 60 tiles (1920px), height = 20 tiles (640px)
    // You are free to extend/modify this map.
    // =========================================================
    const rawLevel = [
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      // left shaft / vertical "room"
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "000000000000000000000000000000000000000000000000000000000000",
      "111100000000000011111111000000000000000000000000000000000000",
      "100100000000000010000001000000000000022220000000000000000000",
      "100100000000000010000001000000000000011110000000000000000000",
      "100100000000000010000001000000000000011110000000000000000000",
      "100111110000000010000001000000002220011110000000000000000000",
      "111111111111111111111111111111111111111111111111111111111111",
      "111111111111111111111111111111111111111111111111111111111111"
    ];

    const levelData = rawLevel.map(row => row.split("").map(n => parseInt(n, 10)));
    const levelWidth = levelData[0].length;
    const levelHeight = levelData.length;

    // =========================================================
    // CAMERA
    // =========================================================
    const camera = {
      x: 0,
      y: 0,
      w: canvas.width,
      h: canvas.height
    };

    function updateCamera() {
      const targetX = player.x + player.w / 2 - camera.w / 2;
      const targetY = player.y + player.h / 2 - camera.h / 2;

      const smooth = 0.1;
      camera.x += (targetX - camera.x) * smooth;
      camera.y += (targetY - camera.y) * smooth;

      // Clamp to world
      camera.x = Math.max(0, Math.min(camera.x, levelWidth * TILE - camera.w));
      camera.y = Math.max(0, Math.min(camera.y, levelHeight * TILE - camera.h));
    }

    // =========================================================
    // INPUT
    // =========================================================
    const keys = {};
    window.addEventListener("keydown", e => {
      keys[e.key.toLowerCase()] = true;
      keys[e.key] = true;
      if (["ArrowLeft", "ArrowRight", "ArrowUp", " "].includes(e.key)) {
        e.preventDefault();
      }
    });
    window.addEventListener("keyup", e => {
      keys[e.key.toLowerCase()] = false;
      keys[e.key] = false;
    });

    function isLeftPressed() {
      return keys["a"] || keys["arrowleft"];
    }
    function isRightPressed() {
      return keys["d"] || keys["arrowright"];
    }
    function isJumpPressed() {
      return keys["w"] || keys["arrowup"] || keys[" "];
    }
    function isDashPressed() {
      return keys["shift"] || keys["shiftleft"];
    }
    function isPurifyPressed() {
      return keys["e"];
    }
    function isAttackPressed() {
      return keys["j"] || keys["z"];
    }

    // =========================================================
    // TILE HELPERS
    // =========================================================
    function getTileAtPixel(px, py) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (tx < 0 || ty < 0 || tx >= levelWidth || ty >= levelHeight) {
        return TILE_SOLID;
      }
      return levelData[ty][tx];
    }

    function setTileAtPixel(px, py, val) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (tx < 0 || ty < 0 || tx >= levelWidth || ty >= levelHeight) return;
      levelData[ty][tx] = val;
    }

    function isSolidTile(t) {
      return t === TILE_SOLID || t === TILE_CORRUPTED || t === TILE_PURIFIED;
    }

    function aabbOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    // =========================================================
    // PLAYER
    // =========================================================
    const player = {
      x: 4 * TILE,
      y: 8 * TILE,
      w: 24,
      h: 32,
      vx: 0,
      vy: 0,
      facing: 1,
      onGround: false,
      isWallClinging: false,
      wallDir: 0,
      isDashing: false,
      dashTimer: 0,
      dashCooldown: 0,
      // attack
      isAttacking: false,
      attackTimer: 0,
      attackCooldown: 0,
      alive: true,
      respawnX: 4 * TILE,
      respawnY: 8 * TILE
    };

    function resetPlayer() {
      player.x = player.respawnX;
      player.y = player.respawnY;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;
      player.isWallClinging = false;
      player.isDashing = false;
      player.dashTimer = 0;
      player.dashCooldown = 0;
      player.isAttacking = false;
      player.attackTimer = 0;
      player.attackCooldown = 0;
      player.alive = true;
    }

    function updatePlayer() {
      if (!player.alive) return;

      let move = 0;
      if (isLeftPressed()) move -= 1;
      if (isRightPressed()) move += 1;

      if (move !== 0) player.facing = move;

      // Dash
      if (!player.isDashing && player.dashCooldown <= 0 && isDashPressed() && move !== 0) {
        player.isDashing = true;
        player.dashTimer = DASH_TIME;
        player.vx = player.facing * DASH_SPEED;
        player.vy = 0;
      }

      if (player.isDashing) {
        player.dashTimer--;
        if (player.dashTimer <= 0) {
          player.isDashing = false;
          player.dashCooldown = DASH_COOLDOWN;
        }
      } else {
        // Normal horizontal movement
        player.vx += move * MOVE_SPEED;
        player.vx *= FRICTION;
        if (player.vx > MAX_X_SPEED) player.vx = MAX_X_SPEED;
        if (player.vx < -MAX_X_SPEED) player.vx = -MAX_X_SPEED;
      }

      // Gravity
      player.vy += GRAVITY;

      // Wall clinging
      player.isWallClinging = false;
      player.wallDir = 0;

      if (!player.onGround && !player.isDashing) {
        // Left wall
        const left1 = getTileAtPixel(player.x - 1, player.y + 4);
        const left2 = getTileAtPixel(player.x - 1, player.y + player.h - 4);
        if (isSolidTile(left1) || isSolidTile(left2)) {
          if (isLeftPressed()) {
            player.isWallClinging = true;
            player.wallDir = -1;
          }
        }
        // Right wall
        const right1 = getTileAtPixel(player.x + player.w + 1, player.y + 4);
        const right2 = getTileAtPixel(player.x + player.w + 1, player.y + player.h - 4);
        if (isSolidTile(right1) || isSolidTile(right2)) {
          if (isRightPressed()) {
            player.isWallClinging = true;
            player.wallDir = 1;
          }
        }
        if (player.isWallClinging && player.vy > 2) {
          player.vy = 2; // slow sliding down
        }
      }

      // Jump / Wall jump
      if (isJumpPressed()) {
        if (player.onGround) {
          player.vy = JUMP_FORCE;
          player.onGround = false;
        } else if (player.isWallClinging) {
          player.vy = WALL_JUMP_FORCE_Y;
          player.vx = -player.wallDir * WALL_JUMP_FORCE_X;
          player.isWallClinging = false;
        }
      }

      // Attack
      if (!player.isAttacking && player.attackCooldown <= 0 && isAttackPressed()) {
        player.isAttacking = true;
        player.attackTimer = ATTACK_TIME;
        player.attackCooldown = ATTACK_COOLDOWN;
      }
      if (player.isAttacking) {
        player.attackTimer--;
        if (player.attackTimer <= 0) {
          player.isAttacking = false;
        }
      } else {
        if (player.attackCooldown > 0) player.attackCooldown--;
      }

      // Move & collisions
      let newX = player.x + player.vx;
      let newY = player.y + player.vy;

      // Horizontal collision
      if (player.vx > 0) {
        if (
          isSolidTile(getTileAtPixel(newX + player.w, player.y + 2)) ||
          isSolidTile(getTileAtPixel(newX + player.w, player.y + player.h - 2))
        ) {
          newX = Math.floor((newX + player.w) / TILE) * TILE - player.w - 0.01;
          player.vx = 0;
        }
      } else if (player.vx < 0) {
        if (
          isSolidTile(getTileAtPixel(newX, player.y + 2)) ||
          isSolidTile(getTileAtPixel(newX, player.y + player.h - 2))
        ) {
          newX = Math.floor(newX / TILE + 1) * TILE + 0.01;
          player.vx = 0;
        }
      }

      // Vertical collision
      let onGround = false;
      if (player.vy > 0) {
        if (
          isSolidTile(getTileAtPixel(newX + 2, newY + player.h)) ||
          isSolidTile(getTileAtPixel(newX + player.w - 2, newY + player.h))
        ) {
          newY = Math.floor((newY + player.h) / TILE) * TILE - player.h - 0.01;
          player.vy = 0;
          onGround = true;
        }
      } else if (player.vy < 0) {
        if (
          isSolidTile(getTileAtPixel(newX + 2, newY)) ||
          isSolidTile(getTileAtPixel(newX + player.w - 2, newY))
        ) {
          newY = Math.floor(newY / TILE + 1) * TILE + 0.01;
          player.vy = 0;
        }
      }

      player.x = newX;
      player.y = newY;
      player.onGround = onGround;

      if (player.dashCooldown > 0 && !player.isDashing) {
        player.dashCooldown--;
      }

      // Purify nearby corrupted tiles
      if (isPurifyPressed()) {
        const radius = 80;
        const cx = player.x + player.w / 2;
        const cy = player.y + player.h / 2;
        for (let ty = 0; ty < levelHeight; ty++) {
          for (let tx = 0; tx < levelWidth; tx++) {
            if (levelData[ty][tx] === TILE_CORRUPTED) {
              const centerX = tx * TILE + TILE / 2;
              const centerY = ty * TILE + TILE / 2;
              const dx = centerX - cx;
              const dy = centerY - cy;
              if (dx * dx + dy * dy < radius * radius) {
                levelData[ty][tx] = TILE_PURIFIED;
              }
            }
          }
        }
      }

      // Fall out of world
      if (player.y > levelHeight * TILE + 200) {
        player.alive = false;
        setTimeout(resetPlayer, 400);
      }
    }

    // =========================================================
    // ENEMIES
    // =========================================================
    const enemies = [
      // lower area, central platform
      { x: 22 * TILE, y: 13 * TILE, w: 24, h: 24, vx: 1.0, vy: 0, leftBound: 21 * TILE, rightBound: 26 * TILE, alive: true },
      // corrupted zone on right
      { x: 40 * TILE, y: 14 * TILE, w: 24, h: 24, vx: -1.2, vy: 0, leftBound: 37 * TILE, rightBound: 45 * TILE, alive: true },
      { x: 45 * TILE, y: 14 * TILE, w: 24, h: 24, vx: 1.2, vy: 0, leftBound: 45 * TILE, rightBound: 53 * TILE, alive: true },
      // upper left area (reachable via wall climbing)
      { x: 8 * TILE, y: 12 * TILE, w: 24, h: 24, vx: 0.9, vy: 0, leftBound: 7 * TILE, rightBound: 12 * TILE, alive: true }
    ];

    function enemyGroundY(e) {
      // simple: vertical collision with tiles below
      e.vy += GRAVITY;
      let newY = e.y + e.vy;
      // check collision down
      const footLeft  = getTileAtPixel(e.x + 2, newY + e.h);
      const footRight = getTileAtPixel(e.x + e.w - 2, newY + e.h);
      if (isSolidTile(footLeft) || isSolidTile(footRight)) {
        newY = Math.floor((newY + e.h) / TILE) * TILE - e.h - 0.01;
        e.vy = 0;
      }
      e.y = newY;
    }

    function updateEnemies() {
      enemies.forEach(e => {
        if (!e.alive) return;

        // horizontal patrol
        e.x += e.vx;
        if (e.x < e.leftBound) {
          e.x = e.leftBound;
          e.vx *= -1;
        }
        if (e.x + e.w > e.rightBound) {
          e.x = e.rightBound - e.w;
          e.vx *= -1;
        }

        enemyGroundY(e);

        // if no solid ground under, reverse direction
        const underLeft  = getTileAtPixel(e.x + 4, e.y + e.h + 1);
        const underRight = getTileAtPixel(e.x + e.w - 4, e.y + e.h + 1);
        if (!isSolidTile(underLeft) && !isSolidTile(underRight)) {
          e.vx *= -1;
        }

        // collision with player (touch damage)
        if (player.alive && aabbOverlap(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          // simple: kill player
          player.alive = false;
          setTimeout(resetPlayer, 400);
        }
      });
    }

    // Attack hitbox and enemy damage
    function handlePlayerAttackOnEnemies() {
      if (!player.isAttacking) return;

      const range = 28;
      const attackWidth = 26;
      const attackHeight = 20;

      const ax = player.facing > 0 ? player.x + player.w : player.x - attackWidth;
      const ay = player.y + 4;

      enemies.forEach(e => {
        if (!e.alive) return;
        if (aabbOverlap(ax, ay, attackWidth, attackHeight, e.x, e.y, e.w, e.h)) {
          e.alive = false;
        }
      });

      // visual (optional: debug draw, disabled in final to keep clean)
      // ctx.fillStyle = "rgba(255,255,0,0.2)";
      // ctx.fillRect(ax - camera.x, ay - camera.y, attackWidth, attackHeight);
    }

    // =========================================================
    // DRAW
    // =========================================================
    function drawLevel() {
      const startX = Math.floor(camera.x / TILE);
      const endX = Math.ceil((camera.x + camera.w) / TILE);
      const startY = Math.floor(camera.y / TILE);
      const endY = Math.ceil((camera.y + camera.h) / TILE);

      for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
          if (y < 0 || y >= levelHeight || x < 0 || x >= levelWidth) continue;
          const t = levelData[y][x];
          if (t === TILE_EMPTY) continue;

          let color = "#555";
          if (t === TILE_CORRUPTED) color = "#6a0dad";
          else if (t === TILE_PURIFIED) color = "#2bbd1f";

          const px = x * TILE - camera.x;
          const py = y * TILE - camera.y;
          ctx.fillStyle = color;
          ctx.fillRect(px, py, TILE, TILE);
        }
      }
    }

    function drawPlayer() {
      const px = player.x - camera.x;
      const py = player.y - camera.y;

      if (!player.alive) {
        ctx.globalAlpha = 0.4;
      }

      ctx.fillStyle = "#00bfff";
      ctx.fillRect(px, py, player.w, player.h);

      // face
      ctx.fillStyle = "#fff";
      const eyeX = player.facing > 0 ? px + player.w - 8 : px + 2;
      const eyeY = py + 8;
      ctx.fillRect(eyeX, eyeY, 4, 4);

      // attack visual
      if (player.isAttacking) {
        ctx.fillStyle = "rgba(255,255,0,0.4)";
        const attackWidth = 26;
        const attackHeight = 20;
        const ax = player.facing > 0 ? px + player.w : px - attackWidth;
        const ay = py + 4;
        ctx.fillRect(ax, ay, attackWidth, attackHeight);
      }

      ctx.globalAlpha = 1.0;
    }

    function drawEnemies() {
      enemies.forEach(e => {
        if (!e.alive) return;
        const ex = e.x - camera.x;
        const ey = e.y - camera.y;

        ctx.fillStyle = "#ff3333";
        ctx.fillRect(ex, ey, e.w, e.h);

        ctx.fillStyle = "#000";
        ctx.fillRect(ex + 6, ey + 6, 4, 4);
      });
    }

    function drawUI() {
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0, 0, 260, 56);
      ctx.fillStyle = "#fff";
      ctx.font = "12px sans-serif";
      ctx.fillText("Corrupted Zone Metroidvania Demo", 10, 16);
      ctx.fillText("Climb the shaft on the left to", 10, 30);
      ctx.fillText("reach the upper area. Purify with E.", 10, 44);
    }

    // =========================================================
    // MAIN LOOP
    // =========================================================
    function loop() {
      updatePlayer();
      updateEnemies();
      handlePlayerAttackOnEnemies();
      updateCamera();

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawLevel();
      drawEnemies();
      drawPlayer();
      drawUI();

      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
